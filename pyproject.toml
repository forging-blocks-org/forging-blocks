[tool.poetry]
name = "forging-blocks"
version = "0.3.6"
description = "Composable toolkit for clean, testable, and maintainable Python applications"
authors = ["ForgingBlocks Org <forgingblocksorganization91@gmail.com>"]
license = "MIT"
readme = "README.md"
repository = "https://github.com/forging-blocks-org/forging-blocks"
homepage = "https://forging-blocks-org.github.io/forging-blocks/"
packages = [{ include = "forging_blocks", from = "src" }]
keywords = [
    "clean-architecture",
    "hexagonal-architecture",
    "foundation",
    "ddd",
    "domain-driven-design",
    "architecture",
    "result-type",
    "dependency-inversion",
    "ports-and-adapters",
    "python",
    "toolkit",
    "framework-agnostic",
    "testable",
    "maintainable"
]

[tool.poetry.dependencies]
python = "^3.12"

[tool.poetry.group.dev.dependencies]
ruff = "^0.14.3"
mypy = "^1.16.1"
pytest = "^8.3.3"
pytest-cov = "^5.0.0"
pytest-asyncio = "^0.25.0"
bandit = "^1.7.10"
pre-commit = "^4.2.0"
pyright = "^1.1.404"
poethepoet = "^0.37.0"
libcst = "^1.8.6"

[tool.poetry.group.docs.dependencies]
mkdocs = "^1.6.1"
mkdocs-material = "^9.6.23"
mkdocstrings = { extras = ["python"], version = "^0.30.1" }
mkdocs-gen-files = "^0.5.0"
mkdocs-literate-nav = "^0.6.2"
mkdocs-autorefs = "^1.4.3"
mkdocs-mermaid2-plugin = "^1.2.3"
mkdocs-section-index = "^0.3.10"
mike = "^2.1.3"

[build-system]
requires = ["poetry-core>=1.9.0"]
build-backend = "poetry.core.masonry.api"

[tool.ruff]
target-version = "py312"
line-length = 100
src = ["src", "tests", "scripts"]
fix = true
extend-exclude = ["site", "tests", "scripts"]

[tool.ruff.lint]
select = ["E", "W", "F", "I", "B", "C4", "D"]
ignore = ["B008", "D105", "D106", "D107", "D203", "D213"]
pydocstyle.convention = "google"

[tool.ruff.lint.isort]
known-first-party = ["forging_blocks"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
docstring-code-format = true

[tool.coverage.run]
omit = [
  "*/foundation/debuggabke.py",
  "*/foundation/mapper.py",
  "*/foundation/result.py",
  "*/foundation/result_mapper.py",
  "*/foundation/ports.py",
  "*/ports/*.py",
  "*/ports/**/*.py"
]

[tool.coverage.report]
exclude_lines = [
  "# pragma: no cover",
  "class .*\\(.*Protocol.*\\):",
  "@abstractmethod"
]


[tool.mypy]
python_version = "3.12"
disallow_untyped_defs = true
warn_unused_ignores = true
strict_equality = true
show_error_codes = true
mypy_path = "src"
exclude = ["tests/*", "scripts/*"]

[tool.pytest.ini_options]
testpaths = ["tests"]
asyncio_mode = "auto"
addopts = [
  "--strict-markers",
  "--strict-config",
  "--cov=forging_blocks",
  "--cov-report=term-missing"
]

[tool.poe.tasks]
# ---------------- Quality and security ----------------
lint = { cmd = "ruff check ." }
"lint:fix" = { cmd = "ruff check . --fix" }
"type" = { cmd = "mypy src" }
test = { cmd = "pytest -q --disable-warnings" }
bandit = { cmd = "bandit -r src -x tests" }

# ---------------- Documentation ----------------
"docs:generate" = { cmd = "python scripts/generate_autodoc_pages.py" }

"docs:serve".sequence = [
  { cmd = "poetry run python scripts/generate_autodoc_pages.py" },
  { cmd = "poetry run mkdocs serve" }
]

"docs:build".sequence = [
  { cmd = "poetry run python scripts/generate_autodoc_pages.py" },
  { cmd = "poetry run mkdocs build --strict" }
]

"docs:deploy".sequence = [
  { cmd = "poetry run python scripts/generate_autodoc_pages.py" },
  { cmd = "poetry run mkdocs gh-deploy --force --clean" }
]

# ---------------- CI Pipelines ----------------
"ci:check".sequence = [
  "lint",
  "type",
  "test",
  "bandit"
]

"ci:simulate".sequence = [
  "ci:check",
  "docs:build"
]

"ci:release".sequence = [
  "ci:simulate",
  { cmd = "poetry build" },
  { shell = "VERSION=$(poetry version -s)" },
  { shell = "echo 'Release candidate validated for version $VERSION'" }
]

# ---------------- Release workflow ----------------
"release:prepare".sequence = [
  { shell = "VERSION=$(poetry version -s)" },
  { cmd = "git add pyproject.toml README.md mkdocs.yml docs/" },
  { shell = "git commit -m 'release: $VERSION'" },
  { shell = "git tag v$VERSION" },
  { shell = "echo 'Tagged v$VERSION â€” push to trigger CI/CD release'" }
]
